### 概述
##### 操作系统的特征
- 并发、共享、虚拟、异步，其中最基本的特征是**并发**和**共享**
##### 各种操作系统
- 单道批处理：只能顺序执行，资源利用率低
- 多道批处理：可以宏观上并发，微观上串行，需要中断支持
- 分时操作系统：引入时间片概念，目的是提供人机交互能力
- 实时操作系统：在规定时间内处理完规定的任务
- 网络和分布式操作系统
- 个人操作系统
##### 内核
- 微内核：策略与机制分离，只把与硬件相关的部分以及底层操作放入内核，例如进程管理、低级存储器管理、中断和陷入处理，优点是扩展方便，安全，缺点是性能差
- 外核：不对资源进行映射，而是对资源进行划分，外核要做的工作只是确保多个虚拟机彼此不发生冲突
### 进程和线程
##### 进程创建
- 如果创建进程的时候先申请进程号，如果能申请到，那么进入创建态；然后开始分配资源，若分配成功，进程进入就绪态
##### 进程通信
- 低级通信是PV操作
- 共享存储，低级：基于数据结构的共享；高级：基于存储区的共享
- 消息传递，直接通信：把消息挂到接收进程的消息缓冲队列；间接通信：把消息发送到信箱
- 管道通信（一个管道只能允许单向通信）
- 信号
##### 各种调度
- 高级调度（作业调度）：把外存的数据搬到内存建立一个进程，一个作业只调入调出一次
- 中级调度（内存调度）：就是swap，把暂时不能运行的进程内存页交换到外存（在外存里的进程状态是挂起态）
- 低级调度（进程调度）：就是进程调度
##### 作业执行相关的计算
- CPU利用率：CPU有效工作时间/总时间
- 周转时间=作业完成时间-作业提交时间
- 平均周转时间=n个作业周转时间之和/n
- **带权周转时间**=作业周转时间/作业实际运行时间
- 平均带权周转时间=n个作业带权周转时间之和/n
##### 常见的进程调度算法的特点
|       |  先来先服务  |      短作业优先      |               高相应比优先               |       时间片轮转        |        多级反馈队列        |
| :---: | :-----: | :-------------: | :--------------------------------: | :----------------: | :------------------: |
| 是否可抢占 |    否    |        是        |                 否                  |         是          |     队列间可以，队列内不一定     |
|  优点   | 公平、实现简单 | 平均等待时间和平均周转时间最优 |               兼顾长短作业               |       兼顾长短作业       | 兼顾长短作业，有较好的响应时间，可行性强 |
|  缺点   | 不利于短作业  | 长作业会饥饿，估计时间不确定  | 计算相应比的开销大，相应比=(等待时间+要求服务时间)/要求服务时间 | 平均等待时间较长，上下文切换浪费时间 |        实现最复杂         |
|  适用于  |    无    |      批处理系统      |                 无                  |        分时系统        |         相当通用         |
##### 临界区互斥准则
- 空闲让进
- 忙则等待
- 有限等待
- 让权等待
##### Peterson算法
- 假设有两个进程要同时进入临界区，那么要设置两个flag标志，表示双方是否想进入临界区，另外设置一个turn标志，表示轮到谁进入临界区，进程0的伪代码如下：```
```C
falg[0] = true;  // 表示自己想进入临界区
turn = 1;  // 表示优先让对方进入临界区
while(flag[1] && turn == 1);  //如果对方也想进入并且轮到对方进入，等待
// 临界区
flag[0] = false;  // 退出临界区
```
显然，turn标志只有在双方都想进入临界区的时候才有用，若对方不想进入临界区，则我方可以直接进入
##### 生产者-消费者问题
- 经典同步问题，关键点在于缓冲区互斥访问，且一次只能有一个生产者或消费者进入缓冲区，典型解决方式如下：```
```C
semaphore mutex = 1;  // 互斥访问锁
semaphore empty = n;  // 缓冲区大小，初始全为空
semaphore full = 0;  // 初始时没有准备好的数据
producer(){  // 生产者
	while(1){
		// 生产一个数据
		P(empty);
		P(mutex);
		// 放入一个数据
		V(mutex);
		V(full);
	}
}
consumer(){
	while(1){
		P(full);
		P(mutex);
		// 消耗一个数据
		V(mutex);
		V(empty);
	}
}
```
##### 读者写者问题
- 一个缓冲区可以允许多个读者同时读缓冲区，但同一时间只允许一个写者写缓冲区，关键在于需要一个计数器统计读者的数量，并且有写请求时，读者应暂缓进入缓冲区，典型解决方式如下：```
```C
int count = 0;  // 读者数量计数器
semaphore mutex = 1;  // 保护读者数量计数器的锁
semaphore rw = 1; // 保证读者写者互斥访问的锁
semaphore w = 1;  // 保证写者优先的锁
reader(){  // 读者进程
	while(1){
		P(w);  // 先保证没有写者准备写入
		P(mutex);
		if(count == 0){
			P(rw);  // 若此前没有读者，对读写锁加锁，表示不能写
		}
		count++;
		V(mutex);
		V(w);  // 更新完读者数量之后必须释放锁，以保证后续的读者和写者可以获取锁
		// 读缓冲区
		P(mutex);
		count--;
		if(count == 0){
			V(rw);  // 最后一个读者离开缓冲区，此时缓冲区可读写
		}
		V(mutex);
	}
}
writer(){
	while(1){
		P(w);  // 表示此时写者准备写入，由此开始读进程无法进入缓冲区
		P(rw);  // 等在所有已经在缓冲区的读者离开缓冲区
		// 写数据
		V(rw);  // 缓冲区使用完毕
		V(w);  // 此写进程已使用完毕，释放锁供其他读者或写者访问
	}
}
```
##### 哲学家就餐问题
- n个哲学家围着一张圆桌，每个哲学家左右手各有一根筷子，一共n根筷子，哲学家需要就餐和思考，只有同时拿起左右手的筷子才能就餐，典型解决方式如下：```
```C
semaphore sticks[n] = {1};
semaphore mutex = 1;
philosopher_i(){
	while(1){
		P(mutex);
		P(sticks[i]);
		P(sticks[(i+1)%n]);
		V(mutex);
		// 就餐
		V(sticks[(i+1)%n]);
		V(sticks[i]);
		// 思考
	}
}
```
##### 管程
- 本质上说，一个管程的实例就是一个资源分配器，这个资源分配器每次只能有一个进程访问，所有进程都要通过这个资源分配器来分配资源，如果本次进入管程的进程得到了资源，那么离开管程，继续任务，如果没有得到资源，也要离开管程，但是会被阻塞到这个资源的阻塞队列；总而言之，管程是一个互斥访问的用来资源分配的程序结构
##### 死锁
- 死锁的必要条件：互斥、不可剥夺、请求保持、循环等待
- 解决方法：
	- 死锁预防：破坏四个必要条件之一，一般互斥不可破坏，破坏其他几个条件的方法：
		1. 破坏不可剥夺：资源得不到满足时，进程必须释放已申请的资源
		2. 破环请求保持：一次性申请所有资源，或把已申请的资源全部释放之后才允许申请新的资源
		3. 破坏循环等待：资源编号，按编号顺序申请
	- 死锁避免：银行家算法
	- 死锁检测：资源分配图：圆圈表示进程，方框表示资源，方框里的圆圈表示资源数，方框到圆圈的一条有向边表示有一个资源分配给了进程，圆圈到方框的一个有向边表示进程申请一个资源；找到一个可以运行的进程，去掉它的所有边，重复步骤，如果能消掉所有边，没有死锁，否则有死锁。
	- 检测到死锁后可以：资源剥夺、撤销进程、进程回退
### 内存管理
##### 程序装入
- 绝对装入：只适用于单道程序环境，编译时用的所有地址都是绝对地址，也就是实际内存地址
- 可重定位装入（静态重定位）：这种方式需要把程序段一次性全部装入内存，编译时用的地址是相对地址，装入时要对地址进行修改
- 动态运行时装入（动态重定位）：为了支持一段一段的把程序放入内存，编译时用的还是相对地址，但装入时不进行地址修改，直到执行时才进行地址修改，需要一个重定位寄存器支持
##### 链接
- 静态链接：链接时需要修改各个模块的相对地址，以及调用的各种外部符号也改成相对地址
- 装入时动态链接：装入内存时边装入边链接
- 运行时动态链接：运行时需要用到时才链接
##### 连续分配
- 单一连续分配：用户区仅有一道程序
- 固定分区分配：可以把分区划分为**大小相同**或者**大小不同**的分区
- 动态分区分配：
	- 首次适应：从头找
	- 循环首次适应（临近适应）：从上次找到的地方往后找
	- 最佳适应：找到最小的能装如程序的分区，名为最佳，实际上最差，会产生最多的外部碎片
	- 最坏适应：找到最大的能装入程序的分区
##### 分段
- 一个进程有一个段表，一个段表里有很多段表项，一个段表项里包含段长和段的起始地址
- 段的地址空间是二维的，因为段长不固定，所以一定要显示的给出段号和段内偏移
##### 段页式
- 每个段都有一个页表（注意这与真实环境中的不同）
- 段页式读存需要三次，先找段表，再找页表，最后读存
##### Belady异常
- 随着分配的页面增多，缺页次数不减反增，称为Belady异常，**只有FIFO算法会出现Belady异常**
##### CLOCK和改进型CLOCK算法
- CLOCK：进行替换时，如果如果当前指针指向的页面访问位是1，置0，看下一个页面；如果是0，换出，也就是说最多转一圈一定能找到一个可以被换出的页面
- 改进型CLOCK，分为4类页面（第一个数字表示有没有访问，第二个数字表示有没有修改）：
	1. 00：既没有访问也没有修改
	2. 01：没访问但是修改了
	3. 10：访问了但没修改
	4. 11：既访问了又修改了
	第一圈先找00，如果找不到，扫第二圈找01，且在第二圈的时候把访问位清零，然后重复第一圈和第二圈的操作
##### 虚拟内存
- 虚拟内存的大小只与虚拟地址的位数有关（当然实际能用的大小跟内存和硬盘的大小有关）
### 文件管理
##### 硬链接
- 硬链接时，多个文件共享一个inode，inode中有个引用次数
##### 隐式链接分配和显式链接分配
- 隐式链接分配：每个盘块的最后存放下一个盘块的地址，也就是说，如果要访问第n块，要读取n次磁盘
- 显式链接分配：系统维护一个FAT表，文件控制块只需要保存起始块号，然后查FAT表就行
##### 目录
- 文件目录项：一般文件目录项就是FCB，但Unix的文件目录项一般只包含文件名和Inode号
##### 文件系统结构
1. 逻辑文件系统：管理文件系统的元数据，通过FCB维护文件结构，也负责文件保护
2. 文件组织模块：把逻辑块转换成物理块，管理空闲盘块
3. 基本文件系统：向驱动发送读写命令，维护缓冲区
4. IO控制层：包括驱动和中断
##### 文件系统布局
- MBR（主引导扇区）：包含引导程序和分区表
##### 记录空闲盘块的成组链接法
- 首先把盘块分成若干组，但每一组不一定是连续的，每一组的全部组号和块数，存放在前一组的某个盘块中（一般是第一个，也就是空闲盘块号栈的栈底块号指向的块中），第一组的组号和块数存放在超级块中的空闲盘块号栈中
- 分配时，从空闲盘块号栈弹出一个块号，进行分配，如果弹出的是栈底元素，那么把该块中的内容读入空闲盘块号栈，也就是说栈中这一组空闲块分配完了，要分配下一组
- 回收时，把盘块号入栈，若入栈前，栈已满，则把栈中的块数和全部块号放到新回收的块中，并把新回收的块作为栈底
##### 虚拟文件系统
- 抽象了各种文件系统，为用户提供统一的调用接口，抽象了4种对象类型
	1. 超级块：包含各种元数据
	2. 索引节点对象（inode）：与文件和文件夹一对一
	3. 目录项对象：文件目录项，文件夹中存放的数据
	4. 文件对象
### 输入输出管理
##### IO软件层次结构
- 用户层软件→设备独立性软件→设备驱动程序→中断处理程序→硬件
- IO请求的顺序是从前往后，IO应答是从后往前
##### 缓冲区
- 设：
	- C：CPU处理一块数据所需的时间
	- M：把一块数据从缓冲区搬到工作区的时间
	- T：数据充满缓冲区的时间
- 对于单缓冲区，处理一块数据的平均时间是Max(C, T)+M，因为缓冲区的读写是互斥的，所以数据处理和充满缓冲区是并行的，它们和“把数据从缓冲区搬运到工作区”是串行的
- 对于双缓冲区，处理一块数据的平均时间是Max(C+M, T)，由于充满一个缓冲区时，另一个缓冲区可以进行搬运和处理，所以搬运和处理与充满缓冲区并行
- 但要注意，上面说的是平均时间，但是计算实际时间的时候一般要从开始充满缓冲区算起，也就是要加上第一次充满缓冲区的时间
##### 设备分配步骤
- 名词：
	- SDT：系统设备表，整个系统只有一张，记录所有物理设备
	- DCT：保存设备的各个属性，以及指向控制器表的指针
	- COCT：控制器表，表示一个控制器
	- CHCT：通道表，表示一个通道
- 一个通道控制多个控制器，一个控制器控制多个设备，所以分配设备时，先从SDT中找到DCT，然后从DCT中找到COCT，最后从COCT中找到CHCT
##### SPOOLing技术
- 由预输入程序，井管理程序和缓输出程序构成
##### 磁盘管理
1. 出厂时，低级格式化
2. 分区，分区信息记录在MBR中
3. 逻辑格式化（高级格式化）
##### 各类调度算法
- FCFS（先来先服务）：最公平
- SSTF（最短寻道时间优先）：会产生饥饿现象
- SCAN：每次要移动到最远端才能往回移动，来回都能读数据，偏向于处理两端
- C-SCAN：和SCAN一样，但只有单个方向能读数据
- LOOK和C-LOOK：和SCAN跟C-SCAN一样，但不用移动到最远端，注意如果不特别指明，SCAN和C-SCAN就是指LOOK和C-LOOK
- 要注意的是，磁头臂黏着现象只有FCFS不会产生