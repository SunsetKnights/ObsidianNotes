### 绪论
##### 算法的特性
- 一个算法应当具有的特性：
	1. 有穷性
	2. 确定性
	3. 可行性
	4. 输入
	5. 输出
- 一个好的算法应当考虑达到的目标
	1. 正确性
	2. 可读性
	3. 健壮性
	4. 高效率与低存储量要求
### 线性表
##### 顺序表各类操作的分析
- 若顺序表目前有n个元素，且在每个位置新增元素的概率相同，那么：
	- 插入一个元素：插入操作需要移动的元素数量的数学期望值为：$\displaystyle\sum_{k=0}^n\frac{k}{n+1}=\frac{1}{n+1}\cdot\frac{n(n+1)}{2}=\frac{n}{2}$，即插入的时间复杂度是$O(n)$
	- 删除一个元素：删除操作需要移动的元素数量的数学期望值为$\displaystyle\sum_{k=0}^{n-1}\frac{k}{n}=\frac{1}{n}\cdot\frac{n(n-1)}{2}=\frac{n-1}{2}$，即删除的时间复杂度是$O(n)$
##### 链表
- 头节点是不存信息的节点，头指针是指向第一个带有数据的节点的指针
### 栈、队列和数组
##### 卡兰特数
- n个不同元素入栈时，可获得$\displaystyle\frac{1}{n+1}\mathrm C_{2n}^n$种不同的出栈序列
##### 中缀表达式转后缀表达式
- 遇到左括号入栈，遇到右括号出栈至左括号
- 遇到运算符，把所有优先级**大于等于**当前运算符的全部出栈，当前运算符入栈
### KMP
##### next数组
- 当模式串的第j个结果不匹配时，$j=next[j]$，继续比较
- 手算方法，设模式串为ababaaababaa（假设模式串和next下标都从1开始）：
	1. $next[1]=0$、$next[2]=1$，若第一个元素失配，主串指针后移，若第二个元素失配，从第一个元素开始比较，这两个是固定的

|  0  |  1  |     |     |     |     |     |     |     |     |     |     |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|  a  |  b  |  a  |  b  |  a  |  a  |  a  |  b  |  a  |  b  |  a  |  a  |
|     |  a  |  b  |  a  |  b  |  a  |  a  |  a  |  b  |  a  |  b  |  a  |

|  0  |  1  |  1  |  2  |  3  |  4  |     |     |     |     |     |     |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|  a  |  b  |  a  |  b  |  a  |  a  |  a  |  b  |  a  |  b  |  a  |  a  |
|     |     |  a  |  b  |  a  |  b  |  a  |  a  |  a  |  b  |  a  |  b  |

|  0  |  1  |  1  |  2  |  3  |  4  |  2  |     |     |     |     |     |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|  a  |  b  |  a  |  b  |  a  |  a  |  a  |  b  |  a  |  b  |  a  |  a  |
|     |     |     |     |     |  a  |  b  |  a  |  b  |  a  |  a  |  a  |

|  0  |  1  |  1  |  2  |  3  |  4  |  2  |  2  |  3  |  4  |  5  |  6  |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|  a  |  b  |  a  |  b  |  a  |  a  |  a  |  b  |  a  |  b  |  a  |  a  |
|     |     |     |     |     |     |  a  |  b  |  a  |  b  |  a  |  a  |
- 也就是说，计算当前的next时，看看前面有几个一样的，当前的next值就是一样的个数加一，若前面有不一样的，就往后挪，挪到当前位置前面完全一样为止
- 注意如果下标从0开始，那么next数组的每个数字都要-1
##### 修正后的next数组
- 首先按照上面的方法求出next数组
- 若跳转的位置和当前位置一样，那么就再跳转一次，直到前面没有元素或跟当前元素不一样
### 树
##### 高度为h的m叉树中节点个数
- 最多：$\displaystyle\sum_{i=0}^{h-1}m^i=\frac{1\cdot(1-m^h)}{1-m}=\frac{m^h-1}{m-1}$
- 最少：$h+m-1$，也就是说只有一层有m个节点，其他每层都只有1个节点
##### n个节点的m叉树高度
- 最高：也就意味着节点个数最少，由于$n=h+m-1$，可得$h=n-m+1$
- 最低：意味着节点最多，由于$\displaystyle n=\frac{m^h-1}{m-1}$，故$h=\left\lceil\log_m[n(m-1)+1]\right\rceil$
##### 以数组保存的m叉树
- 若数组下标从0开始，那么0的子节点是1~m，1的子节点是m+1~2m，故i的子节点编号是im+1~(i+1)m
##### 构造二叉树
- 中序序列加上任意一种序列可以唯一确定一棵二叉树
##### 线索二叉树
- tag=0表示孩子，tag=1表示线索
- 只有后序线索二叉树的遍历需要栈的支持
- 线索二叉树无法有效求解后序后继
##### 并查集
- 并查集在查询时更新代表元
### 图
##### 定义
- 图的顶点集一定非空
- **有向图**讨论**强连通性**，**无向图**讨论**连通性**
- 极大连通子图要求包含尽可能多的边和顶点，极小连通子图则要求包含尽可能少的边
##### 邻接矩阵表示
- 适合存储稠密（边数较多）图
- $A^n[i][j]$表示从i到j长度为n的路径数目
##### 十字链表和邻接多重表
- **十字链表**用于**有向图**，**临接多重表**用于**无向图**
- 十字链表法：弧节点有5个域，分别指向弧头节点，弧尾节点，指向相同弧头的下一条边，指向相同弧尾的下一条边，以及弧信息；顶点节点有3个域，分别是以该节点为弧头的第一条边，以该节点为弧尾的第一条边，节点信息
- 邻接多重表：与十字链表几乎一致
##### DFS和BFS
- BFS可用来求解单源最短路径问题
- 邻接矩阵的BFS和DFS产生的序列是唯一的，但邻接表不是唯一的
- DFS和BFS的时间复杂度和空间复杂度相同，具体而言：

|       |      邻接表       |    邻接矩阵    |
| :---: | :------------: | :--------: |
| 时间复杂度 | O(\|V\|+\|E\|) | O(\|V\|^2) |
| 空间复杂度 |    O(\|V\|)    |  O(\|V\|)  |
##### Prim算法和Kruskal算法（最小生成树）
- Prim：初始时随机选择一点，之后每次选择一个距离最近的点，时间复杂度为$O(|V|^2)$，适合边稠密图
- Kruskal：每次选择一条权值最小且不形成回路的边，时间复杂度是$O(|E|log_2|E|)$，适合边稀疏图
##### Dijkstra和Floyd算法（最短路径）
- Dijkstra：每次选一个距离最近的顶点，并更新距离，不适用于负权值，时间复杂度为$O(|V|^2)$
- Floyd：初始时是一个矩阵，表示各个点之间的距离，之后经过n次迭代，第i次迭代表示考虑在路径中加入i号顶点之后的最短路径，允许边的权值为负，但不允许权值为负的回路，时间复杂度是$O(|V|^3)$
##### 关键路径
- 从源点到汇点权值最大的路径
### 排序
##### 二叉排序树
- 插入时一定在叶节点
##### 平衡二叉树
- 深度为h的平衡二叉树的最少节点数$n_h=n_{h-1}+n_{h-2}+1$，$n_0=0$，$n_1=1$
##### 红黑树
- 根节点和叶节点是黑色，不存在相邻红节点，每条路径黑高相同
- 插入：
	- 若是根节点，染黑
	- 以红色节点插入，若父节点是黑色，结束
	- 若父节点是红色，看叔节点，若叔节点也是红色，把父节点和叔节点染黑，之后网上调整
	- 若叔节点是黑色，旋转，旋转方式和AVL树一样
##### B树
- 对于一个m阶**B树**：**非叶根节点**最少有2棵子树，其他节点最少有$\displaystyle\left\lceil\frac{m}{2}\right\rceil$棵子树，也就是$\displaystyle\left\lceil\frac{m}{2}\right\rceil-1$个关键字
- 插入：插入位置一定是在最底层节点，若不满，直接插入，否则，从$\displaystyle\left\lceil\frac{m}{2}\right\rceil$的位置分裂
- 删除：删除某个关键字，用它的前一个或后一个元素代替，这个元素一定在最底层节点，之后看删除完成之后会不会破坏B树性质，若不会，直接删除，否则，从兄弟节点借，若兄弟节点也不够，合并兄弟节点，使父节点的关键字-1
##### B+树
- 与B树的不同之处在于，m个关键字对应m个子节点（B树m-1个关键字对应m个子节点）
- B+树的关键字都在最底层节点，但其他节点也都是由关键字组成
##### Hash表
- 注意拉链法和线性探测法的区别
##### 冒泡排序
- 注意交换的时候不是i和j交换，而是j和j-1交换
##### 各种排序算法的性质

|   算法   |    最好时间复杂度     |    最差时间复杂度     |    平均时间复杂度     |     空间复杂度     | 稳定性 |
| :----: | :------------: | :------------: | :------------: | :-----------: | :-: |
| 直接插入排序 |     $O(n)$     |    $O(n^2)$    |    $O(n^2)$    |    $O(1)$     | 稳定  |
|  冒泡排序  |     $O(n)$     |    $O(n^2)$    |    $O(n^2)$    |    $O(1)$     | 稳定  |
| 简单选择排序 |    $O(n^2)$    |    $O(n^2)$    |    $O(n^2)$    |    $O(1)$     | 不稳定 |
|  希尔排序  |       ——       |       ——       |       ——       |    $O(1)$     | 不稳定 |
|  快速排序  | $O(n\log_2 n)$ |    $O(n^2)$    | $O(n\log_2 n)$ | $O(\log_2 n)$ | 不稳定 |
|  堆排序   | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(n\log_2 n)$ |    $O(1)$     | 不稳定 |
| 二路归并排序 | $O(n\log_2 n)$ | $O(n\log_2 n)$ | $O(n\log_2 n)$ |    $O(n)$     | 稳定  |
|  基数排序  |  $O(d(n+r))$   |  $O(d(n+r))$   |  $O(d(n+r))$   |    $O(r)$     | 稳定  |
##### 外部排序
- 败者树用来从k个归并段中选择一个加入结果，败者树每个节点保存的都是失败者，由于败者树是一棵完全二叉树，且每个段都是叶节点，那么有k-1个节点用来保存每一个失败者，所以当选中一个成功者加入结果之后，再次比较的时候只需要从叶节点比较到根节点，就能决出下一个胜者
- 置换选择排序用来生成初始归并段
	1. 从工作区中选择一个最小记录的加入新的归并段，并把该记录记为MINIMAX
	2. 从输入文件中加入一个记录到工作区，之后选择**比MINIMAX大的最小的记录**加入归并段，并把MINIMAX的值更新成这个记录
	3. 重复2，直到工作区没有比MINIMAX更大的记录，此时一个归并段结束
	4. 重复1-3，直到读完输入文件中的所有记录
- 正则k叉树用来选择每次归并的不同长度的归并段（$n_0+n_k=n_k\times k+1$）