### 计算机系统概述
##### 各种字长的关系
- **MAR**和**PC**长度相等（其实也不一定，如果指令字定长，可以加个移位器）
- **MDR**的位数和**存储字长**相等
- 机器字长 = **寄存器位数**、**ALU宽度**
##### 相联存储器
- 注意**相联存储器**并非内存，**Cache和快表**都属于相联存储器，所以它既**可以按内容**，又**可以按地址**查找
### 数据表示和运算
##### C语言类型转换的规则
1. 长度相同，机器数相同
2. 长变短，截断
3. 短变长，原本无符号，零扩展；原本有符号，符号扩展
4. 混合运算，类型提升；例如int+float，结果为float
##### 模4补码
- 由于任何正常的补码双符号位是相同的，所以存储时使用两个符号位没有意义，只有在运算时，也就是在ALU中，才使用两个bit表示符号位
##### 反码
- 负数的反码是按位取反，**正数的反码和原码一致**
##### 标志位和求法
- SF（Signal Flag），直接等于运算结果的最高位
- ZF（Zero Flag），看结果是否全为0
- OF（Overflow Flag），$\mathrm{C_n}\oplus \mathrm{C_{n-1}}$，最高位进位和次高位进位异或
- CF（Carry Flag），$\mathrm{C_n}\oplus \mathrm{C_\text{in}}$，最高位进位和低位进位异或（注意在进行减运算的时候低位进位为1）
#####  浮点数
- float：1、8、23，偏移值127
- double：1、11、52，偏移值1023
- 上溢：阶码上溢出，产生**中断（异常）**
- 下溢：阶码下溢出，当成0处理
- 左规**多次**，右规**一次**（之所以如此，是因为左规和右规仅仅在处理运算结果时发生，而运算时由于已经对阶，右规只能是因为结果太大了，但结果再大也只会在小数点前面产生2位有效数字，比如说$9.9\times 9.9$，结果也只是两位整数而已），**右规**会产生阶码**上溢**
- 阶码全0，尾数全0表示0；阶码全0尾数非0表示非规格化数；阶码全1，尾数全0表示无穷；阶码全1，尾数非0表示NaN；
- 非规格化数隐藏位为0，**阶码表示-126（不是-127）或-1022**
- 规格化指第一位有效数字不为0，但**不一定隐藏**，只有IEEE754标准中才会隐藏最前面的1
### 存储系统
##### 存取方式
- 注意顺序存取（磁带）、**直接存取**（光盘、磁盘）、**随机存取**（RAM，ROM）的不同
##### DRAM
- DRAM行缓冲用SRAM
- 注意区分地址线和片选线；比如，256MB的存储器由若干4Mx8b的DRAM芯片组成，那么地址线是$\displaystyle\frac{\log_24\text{M}}{2}=11$根，而非$\displaystyle\frac{\log_2 256\text{M}}{2}=14$根，因为最高位的6根是**片选线**而非**地址线**
- SDRAM：同步动态随机存储器
##### Cache
- Cache块的组成：**脏位**（使用回写法时才需要，**1bit**）、**LRU位**（使用LRU替换算法时才需要，假设使用k路组相联，**占$\log_2k$bit**）、**有效位**（必然存在，**1bit**）、**Tag**（必然存在，占几位取决于映射方式）、**数据位**（必存在）
- Cache有N行，那么有：
	1. 全相联映射（N路组相联映射），有N/N=1组
	2. k路组相联映射，有N/k组
	3. 直接映射（1路组相联映射），有N/1=N组
- 几路组相联就有几个比较器
- LRU命中某行时，组内比该行计数器数值低的全+1，该行计数器归零
##### 虚拟页式存储器（内存分页）
- 一定用回写法+全相联映射
- TLB、Page和Cache命中情况的可能性：
	- 1、1、0
	- 1、1、1
	- 0、1、1
	- 0、1、0
	- 0、0、0
- 也就是说，TLB命中时，Page一定命中，反之不然；Cache命中时，Page一定命中，反之不然；而Page命中时，可能只有Page命中；
##### 一次访存的顺序
1. 首先把虚拟地址分成k+1部分（在k级页表的情况下），分别是各级页表的偏移和页内偏移
2. 把前k个部分扔到TLB中匹配，如果匹配成功，直接获得页的物理地址；否则需要访存k次找到页的物理地址
3. 把物理地址分成Tag，组号和块内偏移，对比Cache，若命中，取数据成功；否则处理Cache缺失，最后取数据
### 指令系统
##### ISA规定的内容
1. 指令格式、指令寻址方式、操作类型、操作对应的操作数
2. 操作数类型、操作数寻址方式、大端序还是小端序
3. 程序可访问的寄存器编号、个数、位数、存储空间大小、编址方式
4. 指令执行中的控制方式
##### 扩展操作码
- 虽然名字叫扩展操作码，但它是定长操作码，只是随着地址数增加，操作码长度减少
##### 寻址方式
- 隐含寻址：隐式给出操作数地址，比如单地址指令默认有一个操作数是ACC
- 立即寻址：（注意与**直接寻址**作出区分）地址码就是操作数
- 直接寻址：EA=A
- 间接寻址：EA=(A)，k次间接寻址要访问k+1次主存
- 寄存器寻址：地址码是寄存器编号，EA=$R_i$
- 寄存器间接寻址：EA=($R_i$)
- 相对寻址：EA=(PC)+A，注意在执行当前指令的时候，PC的值是下一条指令的地址
- 基址寻址：EA=(BR)+A，用于多道程序
- 变址寻址：EA=(IX)+A，用于循环
### 中央处理器
##### 运算器和控制器
- 运算器：包含ALU、暂存器、ACC、GPRs、PSW
- 控制器：包含PC、IR、ID（指令译码器）
##### 指令执行方案和指令周期
- 指令周期一般可分为：
	- 取指周期（取指令）
	- 间指周期（计算EA）
	- 执行周期（取数、执行、存数）
	- 中断周期（响应和处理中断）
- 指令执行方案
	- 单周期（CPI=1）
	- 多周期（CPI>1）
	- 流水线（理想状态下CPI=1）
##### 控制器
- 组成：IR（Instruction Register）、PC（Program Counter）、CU（Control Unit）
- 微指令（包含若干微命令）、微命令和微操作（一一对应，代表一个电信号），一个微指令可以包含若干微命令，一个微命令对应一个微操作，一般执行一个微指令的时间是一个时钟周期，称为一个微周期
- 微指令编码方式：
	- 直接编码：n个微命令需要n位
	- 字段直接编码：把互斥的微命令放到一组，相容的微命令放到不同组，假设某组有k个微命令，那么该组需要$\log_2(k+1)$位来表示，多出的**1位表示什么都不做**
- 水平型微指令和数值型微指令：上面的直接编码和字段直接编码都是水平型微指令，特点是一次可以并行执行多个微命令（微操作），而垂直型微指令一次执行一个微命令
##### 异常和中断
- 指令**运行中**发生的叫**异常**或**内中断**（例如除0，浮点数溢出，缺页）；**运行完成**后检测的叫**中断**或**外中断**（例如定时器时间到）
- 异常：
	- 故障：执行中检测到的异常事件，除0、缺页等
	- 自陷：比如系统调用
	- 终止：硬件故障
- 中断：
	- 可屏蔽中断：INTR线发来的中断
	- 不可屏蔽中断：NMI线发来的中断
- 中断向量表中存放中断向量，中断向量就是中断处理程序的首地址
- 异常和中断的处理大体上是一样的，但并不完全相同，比如中断处理的时候需要设置中断屏蔽字
##### 指令流水线
- 5段流水线：
	1. 取指（IF）：取指令
	2. 译码（ID）：译码，同时从寄存器中取操作数
	3. 执行（EX）：运算、计算EA或者计算转移指令的地址并设置条件码
	4. 访存（MEM）：读写存储器或将转移地址送PC
	5. 写回（WB）：结果写回寄存器
- 流水线冒险
	- 结构冒险：如果指令Cache和数据Cache使用同一个Cache，那么就可能出现使用冲突，解决方法是分离数据Cache和指令Cache，或者后续指令等待
	- 数据冒险（写后读——Read After Write）：后面的指令要等前面的指令执行出结果
		- 插入空指令：插入nop使读指令的ID阶段在写指令的WB阶段之后
		- 旁路技术：使读指令的EX在写指令的EX阶段之后（这个不用插入nop）
		- load-use：插入nop使读指令的EX在load指令的MEM之后
	- 控制冒险：插入nop使下一条指令的IF在转移指令的MEM（地址送PC）之后，或者分支预测
- 吞吐率：$\displaystyle \frac{n}{(n+k-1)\Delta t}$，其中n是任务数，k是流水线段数，$\Delta t$是时钟周期
- 加速比：$\displaystyle\frac{nk}{n+k-1}$
- 多发射流水线：包括超标量流水线，或超长指令字流水线，可做到CPI<1
##### 硬件多线程
- 粗粒度：遇到Cache miss等阻塞流水线的事件后切换线程，指令级并行
- 细粒度：每个周期都可以切换线程，指令级并行
- 同时：两套部件同时运行，线程级并行
- 单核处理器也可以搞硬件多线程
### 总线
##### 总线定时
- 同步：由一个统一的时钟信号协调发送方和接收方，每个周期传送一次数据
- 异步：
	- 不互锁：主设备发送请求信号，一段时间后撤下；从设备发送回答信号，一段时间后撤下
	- 半互锁：主设备发送请求信号，直到收到回答信号才撤下；从设备发送回答信号，一段时间后撤下
	- 全互锁：主设备发送请求信号，直到收到回答信号才撤下；从设备发送回答信号，直到发现请求信号撤下之后才撤下
### 输入/输出系统
##### IO接口
- 注意区分**IO接口**和**IO端口**，IO接口是指整个IO控制器，而IO端口是指IO接口中可以被CPU访问的寄存器
- IO接口（IO控制器）需要实现的功能：
	- 地址译码和设备选择
	- 主机和外设的信息交换控制
	- 数据缓冲
	- 信号格式转换
	- 传送控制命令和状态信息
- 不同的线传送的信号
	- 数据线：数据、状态信息、控制信息、中断类型号
	- 地址线：地址
	- 控制线：读写信号、中断请求响应信号、仲裁信号、握手信号
- 独立编址：地址信息有重叠，需要单独的IO指令；统一编制：地址无重叠，用统一的访存指令
##### 中断
- CPU在中断周期通过**控制线**采样中断请求和响应信号，响应后，通过**数据线**读取中断类型号
- 中断的流程：
	1. 关中断
	2. 保存断点，即PSW和PC
	3. 中断服务程序寻址
	4. 保存现场和屏蔽字（一般需要保存GPRs和PSW、PC，尽管PSW和PC被处理器保存过了，但是处理器一般是保存到某个临时寄存器或者栈，可能被覆盖，所以还是需要操作系统把他们保存到进程上下文）
	5. 开中断
	6. 执行中断服务程序
	7. 关中断
	8. 恢复现场和屏蔽字
	9. 开中断，中断返回
	其中1~3由硬件完成，也就是所谓**中断隐指令**需要完成的部分，5和7是为了支持多重中断
- 中断判优由中断响应电路实现，在进入中断判优电路之前，中断请求寄存器先与中断屏蔽字进行位与操作，这也就意味着，中断屏蔽字**只能改变中断处理优先级**，而**不能改变中断响应优先级**，也就是说，如果A的响应优先级高，但B的处理优先级高，那么他们同时进入中断寄存器时，可以同时被中断响应电路判优，此时当然优先响应A，把A的中断屏蔽字写入寄存器，由于A的屏蔽字并不能屏蔽B（位与之后仍然是1），所以当A保存完现场，打开中断之后，仍然会发现一个中断信号，此时再响应和处理B
##### DMA
-  DMA请求优先级高于中断
- CPU在每个总线周期结束后检查有没有DMA请求，每个机器周期结束后，CPU就可以相应DMA请求
- 只有预处理和后处理需要执行中断处理，但！其他时间当DMA需要传送数据时，需要发送DMA请求，请求使用总线