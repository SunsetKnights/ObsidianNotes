### 数据的表示
##### 基数
每个数码位所用到的不同的符号个数，r进制的基数为r
#### 定点数
##### 十进制转换为其他进制
- 整数部分：除基取余
- 小数部分：乘基取整
##### n位==无符号数==的表示范围
- 0~$2^n-1$，总共$2^n$种不同的状态
##### 定点数的表示
- 原码表示
	- 定点整数：第一位表示正负（0为正，1为负），其余位表示数值，若机器字长为n+1，则表示的范围为：$-(2^n-1)\sim 2^n-1$
	- 定点小数：第一位表示正负（0为正，1为负），其余位表示数值，若机器字长为n+1，则表示的范围为：$-(1-2^{-n})\sim 1-2^{-n}$
- 反码表示
	- 若符号位为0（正数），反码和原码相同		
	- 若符号位为1（负数），反码=原码按位取反（符号位不变）
- 补码表示
	- 若符号位为0，补码=反码=原码
	- 若符号位为1，补码=原码按位取反+1（需要进位），原码=补码按位取反+1（需要进位）
	- n+1位补码的整数范围是$-2^n\sim 2^n-1$，小数范围是$-1\sim 1-2^{-n}$
- 移码表示
	- 移码=补码的符号位取反=真值+偏置值，方便计算机比较有符号数的大小
##### 各类码的作用
- 原码：在进行无符号加法时，使用原码非常方便，流水加法器和超前进位加法器都很容易设计和实现
- ==补码：==如果是有符号整数的运算，在只有加法器的情况下，加上一个负数，等价于加上这个负数与256（假设字长为8位）同余的数字，例如-4，它与-4+256=252同余，而-4的原码是1,0000100、补码是1,1111100，如果把补码看成是无符号整数，它刚好是252，所以使用补码时，加法和减法可以统一用加法器来操作
- 移码：可以很方便的对比有符号数和无符号数的大小
##### 补码小技巧
- 求相反数的补码：把符号位和尾数全部取反，然后+1 ^c70e40
- ==负数==补码快速转换成原码的方式：找到补码最右边的1，然后把这个1左边除符号位全部取反即可
- ==负数==补码的真值和数值位所代表的值的关系：真值的相反数+数值位代表的值=符号位的权重，以此为基础可以进行快速转换：
	- 负数补码转换为真值：符号位权重-数值位的值加负号，例如，1,1011001这个补码，符号位的权重是128，数值位的值是89，那么真值为-(128-89)=-39
	- 负数真值转换为补码：用符号位权重-真值的绝对值，获得的结果转换成二进制，加上符号位即可，例如，-114这个数字，用8位补码表示，128-114=14，那么补码为 1,0001110
##### 不同字长的整数转换
1. 大字长转换成小字长：直接截断高位，例如 0xABCD 是16位字长，转换成8位字长的结果是0xCD
2. 小字长转换成大字长：向高位扩展，扩展出的位数用符号位填充，例如 0x8F 是8位字长，转换成16位之后是 0xFF8F（符号位是1，所以扩充的高位填充1）；0x71 转换之后是 0x0071（符号位是0，所以扩充的高位填充0）
#### 浮点数
##### 浮点数的表示
浮点数由阶码和尾数构成：
- 阶码：用补码或移码表示的定点整数，影响浮点数能表示的范围和小数点的位置，记其真值为E
- 尾数：用原码或补码表示的定点小数，影响浮点数的精度，记其真值为M
浮点数的真值：$N=r^E\times M$，其中$r$为阶码的[[数据的表示和运算#基数|基数]]，通常为2
##### 浮点数的规格化
在用科学计数法表示数字时，尾数最前面的0是不表示任何信息的，为了提高浮点数的精度，可以让尾数从第一个不为0的位开始存储，这就引出了==规格化浮点数：尾数的最高位数值必须是一个有效值==。规格化的方法：
- 左规：当浮点数为非规格化时，尾数左移一位，阶码减1
- 右规：当浮点数尾数溢出时（双符号位是01或10时），尾数右移1位，阶码加1（溢出时舍弃低位好过舍弃高位）
##### 规格化尾数的表示范围
设数值为为n+1位，其中1位符号位，n位数值位
- 原码
	- 原码的数值位最高位是1时为规格化尾数，即0,1XXX...X的形式
	- 正数的表示范围是0,1000...0~0,1111...1，即$\displaystyle{1\over 2}\le M\le\left(1-{1\over 2^n}\right)$
	- 负数的表示范围是1,1111...1~1,1000...0，即$\displaystyle-\left(1-{1\over 2^n}\right)\le M\le -{1\over 2}$
- 补码
	- 补码的数值位最高位和符号位不同的时候为规格化尾数，即0,1XXX...X的形式和1,0XXX...X的形式
	- 正数的表示范围是0,1000...0~0,1111...1，即$\displaystyle{1\over 2}\le M\le\left(1-{1\over 2^n}\right)$
	- 负数的表示范围是1,0000...0~1,0111...1，即$\displaystyle-1\le M\le -\left({1\over 2}+{1\over 2^n}\right)$
##### IEEE 754
浮点数分为三个部分，分别是数符、阶码和尾数数值
- 不同长度的浮点数，各个部分的位数：
	![[Pasted image 20240605214943.png]]
- 数符：表示浮点数的正负性，0表示正，1表示负
- 阶码
	- 阶码用移码表示，偏置值为$2^{n-1}-1$，真值=移码-偏置值
	- 阶码全0（真值：-127）
		- 尾数不全为0时，表示一个非规格化的浮点数，尾数的隐含位视为0，且阶码值视为-126
		- 尾数全为0时，表示 $\pm 0$
	- 阶码全1（真值：-128）
		- 尾数不全为0，表示一个非数值NaN
		- 尾数全为0时，表示$\pm\infty$
- 尾数
	- 尾数用原码表示，最前面隐含了1位，如果是规格化浮点数，隐含的这一位为1，否则为0
### ALU的组成
##### 两种加法器
- 串行进位的并行加法器（流水加法器）太慢！
- 并行进位的并行加法器（超前进位加法器）主流的加法器实现，牛逼！
##### 加法器的标志位
- OF（Overflow Flag）：溢出标志位，用于指示==有符号数==的运算结果是否溢出
	- 0：未溢出
	- 1：溢出
	- OF=$C_n\oplus C_{n-1}$ ^148dd4
- SF（Sign Flag）：符号标志位，用于指示==有符号数==的运算结果的正负性
	- 0：正
	- 1：负
	- SF=$S_n$
- ZF（Zero Flag）：零标志位，用于指示运算结果是否为0
	- 0：结果不为0
	- 1：结果为0
	- ZF=$\overline{S_1+S_2+\text{...}+S_n}$
- CF（Carry Flag）：进位借位标志位，用于指示==无符号数==相加是否产生了进位或相减时是否产生了借位，若问其在有符号数运算时的值，用实现方式看
	- 0：没有产生进位或借位
	- 1：产生了进位或借位
	- CF=$C_{\text{out}}\oplus C_{\text{in}}=C_n\oplus C_0$
##### 如何设计一个超前进位加法器？
- 在全加器中，令输入分别是A和B，输出S，进位输入端$C_{\text{in}}$、进位输出端$C_{\text{out}}$，那么：
	- S=$A\oplus B\oplus C_{\text{in}}$
	- $C_{\text{out}}=(A\cdot B)+(A\cdot C_{\text{in}})+(B\cdot C_{\text{in}})=(A\cdot B)+(C_{\text{in}}\cdot (A\oplus B))$
- n位流水加法器需要n个一位全加器，把他们的进位输入端和进位输出端首位相连即可
- n位超前进位加法器的实现：
	- $C_i=A_i\cdot B_i+(A_i\oplus B_i)\cdot C_{i-1}$
	- 记$G_i=A_i\cdot B_i\quad P_i=A_i\oplus B_i$
	-  $C_i=G_i+P_i\cdot \textcolor{blue}{C_{i-1}}$
	- $C_i=G_i+P_i\cdot (\textcolor{blue}{G_{i-1}+P_{i-1}}\cdot \textcolor{yellow}{C_{i-2}})$
	- 逐层展开，即可以提前获得所有进位信息，由于展开过于复杂，一般只设计4位，之后按照流水加法器的相连方式即可设计出8位、16位等等位数的加法器
##### ALU（Arithmetic and Logic Unit）
- 运算器负责对数据进行处理，ALU是运算器的核心，加法器是ALU的核心
- 其功能包括算术运算（加减乘除）、逻辑运算（与或非）和其他功能（求补码、直送等）
- 如果ALU支持k种功能，则控制信号位数$m\ge \left\lceil\log_2k\right\rceil$ 
- ALU的运算数、运算结果位数与计算机的字长相同
- 上述[[数据的表示和运算#加法器的标志位|加法器的标志位]]中的值会被存入PSW（程序状态字）或FG（标志寄存器）
### 运算
##### 逻辑移位
即无符号位移，若高位的1移出，视为溢出
##### 循环移位
将溢出的位补充到空缺的位，比如 0x8 循环左移 1 位，结果是 0x1
如果是带进位位的循环移位，把进位位看成最高位即可
##### 原码的算数移位
符号位保持不变，仅对数值位进行移位
- 右移：高位补0，低位舍弃。若低位是0，相当于除以2；若低位是1，会丢失精度
- 左移：低位补0，高位舍弃。若高位是0，相当于乘以2；若高位是1，会严重误差
##### 反码的算数移位
符号位保持不变，仅对数值进行移位
- 若符号位是0，反码和原码相同，移位方式也与[[数据的表示和运算#原码的算数移位|原码的算数移位]]完全相同
- 若符号位是1，反码的数值位与原码相反，移位方式跟原码的移位方式唯一的不同点在于要补1
##### 补码的算数移位
- 左移：高位（符号位）移出，低位补0，若左移前后的符号位不同，视为溢出
- 右移：低位移出，高位补符号位
##### 补码的加减运算
- 加法：补码在进行加法运算时，ALU的两个输入分别是$[x]_\text{补}$和$[y]_\text{补}$，$C_\text{in}=0$，把包括符号位的整个补码看成是一个无符号整数，然后按照无符号数字的方式做加法（这样做之所以可行，主要是因为，假设要在8位字长的计算机中计算$A+B$，那么实际上的结果是$(A+B)$%256，其中A是负数，记A的补码为$A_{bin}$，把$A_{bin}$看成一个无符号数$A_{d}$，则有$A\equiv A_d(mod 256)$，根据同余理论，结果显然成立）
- 减法：做减法时，ALU的两个输入分别是$[x]_\text{补}$和$\overline{[y]_\text{补}}$，$C_\text{in}=1$，之所以这样做是因为$[x]_\text{补}-[y]_\text{补}=[x]_\text{补}+[-y]_\text{补}=[x]_\text{补}+\overline{[y]_\text{补}}+1$
由上可知，其实==加减法都会用加法==器来运算
##### 有符号数溢出判断
以8位机为例
 1. 如果两个数字的和超过了127，那么称为发生了上溢：
	- 只有两个正数相加才会产生上溢
	- 上溢发生时，数值位往符号位进1，符号位不产生进位
2. 如果两个数字的和小于-128，那么称为发生了下溢：
	- 只有两个负数相加才会产生下溢
	- 下溢发生时，数值位最高位不进位，符号位进1
由上述两种溢出的进位情况，可以设计[[数据的表示和运算#^148dd4|如上]]的溢出位的电路
##### 无符号数溢出判断
若是加法，最高位进位为1时发生了溢出
若是减法，最高位进位为0时发生了溢出
##### 原码的一位乘法运算
设机器字长为n+1位，被乘数为X，乘数为Y，原码乘法步骤如下：
1. 把被乘数X放入[[计算机系统概述#^75e185|通用寄存器X]]，乘数放入[[计算机系统概述#^956385|乘商寄存器MQ]]，把[[计算机系统概述#^0661b9|累加器ACC]]清零
2. 设MQ的最低位值为a，执行$ACC+a*MQ\longrightarrow ACC$
3. 把ACC和MQ看成一个整体，[[数据的表示和运算#逻辑移位|逻辑右移]]1位
4. 重复执行n次2和3
5. 设X的符号位为$X_s$，Y的符号位为$Y_s$，把ACC的最高位（符号位）更新为$X_s\oplus Y_s$
最终，ACC寄存器中存放结果的高位，MQ寄存器中存放结果的低位
##### 补码的一位乘法运算
设机器字长为n+1位，由于补码的乘法需要一个辅助位，所以MQ寄存器的字长为n+2，统一长度后，ACC和X寄存器也是n+2位，此时MQ寄存器中最高位是符号位，最低位是辅助位，而ACC和X寄存器中采用了最高2位为双符号位的形式。同时，补码的乘法运算中，进行加法的时候，符号位是参与运算的，过程如下：
1. 把被乘数X放入[[计算机系统概述#^75e185|通用寄存器X]]，乘数放入[[计算机系统概述#^956385|乘商寄存器MQ]]，把[[计算机系统概述#^0661b9|累加器ACC]]清零
2. 看MQ最低位（辅助位）减去 次低位（逻辑最低位）的值
	- 若为1，$(ACC)+[x]_\text{补}\longrightarrow ACC$
	- 若为0，$(ACC)+0\longrightarrow ACC$
	- 若为-1，$(ACC)+[-x]_\text{补}\longrightarrow ACC$
3. 把ACC和MQ看成一个整体，[[数据的表示和运算#补码的算数移位|算数右移]]1位
4. 重复执行n次2和3
5. 最后再执行一次2
由于符号位参与运算，最终得出的结果就是真值的补码
##### 原码的恢复余数除法
原码进行除法时，符号位单独处理，之后被除数和除数取绝对值：$|x|\text{、}|y|$
1. $|x|\longrightarrow ACC\quad |y|\longrightarrow X\quad 0\longrightarrow MQ$
2. $(ACC)+[-|y|]_{\text{补}}\longrightarrow ACC$，MQ最低位置1
3. 若ACC符号位为0（正数），把ACC和MQ看成一个整体，逻辑左移1位
4. 若ACC符号位为1（负数），$(ACC)+[|y|]_{\text{补}}\longrightarrow ACC$、MQ最低位置0，把ACC和MQ看成一个整体，逻辑左移1位
5. 循环2、3、4，直到成功左移n位
6. 符号位=$x_s\oplus y_s$
MQ寄存器中的值为商，ACC中的为余数
##### 原码的加减交替除法（不恢复余数除法）
原码进行除法时，符号位单独处理，之后被除数和除数取绝对值：$|x|\text{、}|y|$
1. $|x|-|y|\longrightarrow ACC\quad |y|\longrightarrow X\quad 0\longrightarrow MQ$
2. 若ACC符号位为0（正数），MQ最低为置1，逻辑左移1位，余数-=|除数|
3. 若ACC符号位为1（负数），MQ最低位置0，逻辑左移1位，余数+=|除数|
4. 循环2、3，直到左移n位
5. 若最终余数为负数，需要恢复余数
6. 符号位=$x_s\oplus y_s$
MQ寄存器中的值为商，ACC中的为余数
##### 补码的加减交替除法
特点：
- 符号位参与运算
- 被除数（余数）和除数采用双符号位
$[x]_\text{补}$除以$[y]_\text{补}$的步骤：
1. $[x]_\text{补}+=[y]_\text{补}$
2. 若$[x]_\text{补}$和$[y]_\text{补}$同号，商1，$[x]_\text{补}=[x]_\text{补}<<1-[y]_\text{补}$，注意用算数左移
3. 若$[x]_\text{补}$和$[y]_\text{补}$异号，商0，$[x]_\text{补}=[x]_\text{补}<<1+[y]_\text{补}$，注意用算数左移
4. 重复2、3共n次
5. 商末位恒置1
##### 浮点数加减运算步骤
1. 对阶
	- 小阶向大阶靠齐，注意尾数要变化
2. 尾数加减
	- 尾数进行无符号加减，注意如果是IEEE 754标准，尾数最前面隐含了一位
3. 规格化
	- 进行左规或者右规 
4. 舍入
	-  若结果过长，要舍去尾数
		- 0舍1入法：在右规时，如果尾数的末位是0，直接舍去，如果是1，则在尾数的末位+1，这次+1可能会再次造成溢出，需要再次右规
		- 横置1法：无论丢掉的尾数末位是0还是1，都将末位恒置1
1. 判溢出
	- 阶码超出范围时，溢出，如果是双符号位，那么溢出是可以拯救的，如果是IEEE 754标准则不行