### 数据的表示
##### 基数
每个数码位所用到的不同的符号个数，r进制的基数为r
##### 十进制转换为其他进制
- 整数部分：除基取余
- 小数部分：乘基取整
##### n位==无符号整数==的表示范围
- 0~$2^n-1$，总共$2^n$种不同的状态
##### 定点数的表示
- 原码表示
	- 定点整数：第一位表示正负（0为正，1为负），其余位表示数值，若机器字长为n+1，则表示的范围为：$-(2^n-1)\sim 2^n-1$
	- 定点小数：第一位表示正负（0为正，1为负），其余位表示数值，若机器字长为n+1，则表示的范围为：$-(1-2^{-n})\sim 1-2^{-n}$
- 反码表示
	- 若符号位为0（正数），反码和原码相同		
	- 若符号位为1（负数），反码=原码按位取反（符号位不变）
- 补码表示
	- 若符号位为0，补码=反码=原码
	- 若符号位为1，补码=原码按位取反+1（需要进位），原码=补码按位取反+1（需要进位）
	- n+1位补码的整数范围是$-2^n\sim 2^n-1$，小数范围是$-1\sim 1-2^{-n}$
- 移码表示
	- 移码=补码的符号位取反，方便计算机比较有符号数的大小
##### 各类码的作用
- 原码：在进行无符号加法时，使用原码非常方便，流水加法器和超前进位加法器都很容易设计和实现
- ==补码：==如果是有符号整数的运算，在只有加法器的情况下，加上一个负数，等价于加上这个负数与256（假设字长为8位）同余的数字，例如-4，它与-4+256=252同余，而-4的原码是1,0000100、补码是1,1111100，如果把补码看成是无符号整数，它刚好是252，所以使用补码时，加法和减法可以统一用加法器来操作
- 移码：可以很方便的对比有符号数和无符号数的大小
##### 补码小技巧
- 求相反数的补码：把符号位和尾数全部取反，然后+1 ^c70e40
- ==负数==补码快速转换成原码的方式：找到补码最右边的1，然后把这个1左边除符号位全部取反即可
- ==负数==补码的真值和数值位所代表的值的关系：真值的相反数+数值位代表的值=符号位的权重，以此为基础可以进行快速转换：
	- 负数补码转换为真值：符号位权重-数值位的值加负号，例如，1,1011001这个补码，符号位的权重是128，数值位的值是89，那么真值为-(128-89)=-39
	- 负数真值转换为补码：用符号位权重-真值的绝对值，获得的结果转换成二进制，加上符号位即可，例如，-114这个数字，用8位补码表示，128-114=14，那么补码为 1,0001110
##### 不同字长的整数转换
1. 大字长转换成小字长：直接截断高位，例如 0xABCD 是16位字长，转换成8位字长的结果是0xCD
2. 小字长转换成大字长：向高位扩展，扩展出的位数用符号位填充，例如 0x8F 是8位字长，转换成16位之后是 0xFF8F（符号位是1，所以扩充的高位填充1）；0x71 转换之后是 0x0071（符号位是0，所以扩充的高位填充0）
### ALU的组成
##### 两种加法器
- 串行进位的并行加法器（流水加法器）太慢！
- 并行进位的并行加法器（超前进位加法器）主流的加法器实现，牛逼！
##### 加法器的标志位
- OF（Overflow Flag）：溢出标志位，用于指示==有符号数==的运算结果是否溢出
	- 0：未溢出
	- 1：溢出
	- OF=$C_n\oplus C_{n-1}$ ^148dd4
- SF（Sign Flag）：符号标志位，用于指示==有符号数==的运算结果的正负性
	- 0：正
	- 1：负
	- SF=$S_n$
- ZF（Zero Flag）：零标志位，用于指示运算结果是否为0
	- 0：结果不为0
	- 1：结果为0
	- ZF=$\overline{S_1+S_2+\text{...}+S_n}$
- CF（Carry Flag）：进位标志位，用于指示==无符号数==的运算结果是否溢出
	- 0：未溢出
	- 1：溢出
	- CF=$C_{\text{out}}\oplus C_{\text{in}}=C_n\oplus C_0$
##### 如何设计一个超前进位加法器？
- 在全加器中，令输入分别是A和B，输出S，进位输入端$C_{\text{in}}$、进位输出端$C_{\text{out}}$，那么：
	- S=$A\oplus B\oplus C_{\text{in}}$
	- $C_{\text{out}}=(A\cdot B)+(A\cdot C_{\text{in}})+(B\cdot C_{\text{in}})=(A\cdot B)+(C_{\text{in}}\cdot (A\oplus B))$
- n位流水加法器需要n个一位全加器，把他们的进位输入端和进位输出端首位相连即可
- n位超前进位加法器的实现：
	- $C_i=A_i\cdot B_i+(A_i\oplus B_i)\cdot C_{i-1}$
	- 记$G_i=A_i\cdot B_i\quad P_i=A_i\oplus B_i$
	-  $C_i=G_i+P_i\cdot \textcolor{blue}{C_{i-1}}$
	- $C_i=G_i+P_i\cdot (\textcolor{blue}{G_{i-1}+P_{i-1}}\cdot \textcolor{yellow}{C_{i-2}})$
	- 逐层展开，即可以提前获得所有进位信息，由于展开过于复杂，一般只设计4位，之后按照流水加法器的相连方式即可设计出8位、16位等等位数的加法器
##### ALU（Arithmetic and Logic Unit）
- 运算器负责对数据进行处理，ALU是运算器的核心，加法器是ALU的核心
- 其功能包括算术运算（加减乘除）、逻辑运算（与或非）和其他功能（求补码、直送等）
- 如果ALU支持k种功能，则控制信号位数$m\ge \left\lceil\log_2k\right\rceil$ 
- ALU的运算数、运算结果位数与计算机的字长相同
- 上述[[数据的表示和运算#加法器的标志位|加法器的标志位]]中的值会被存入PSW（程序状态字）或FG（标志寄存器）
### 运算
##### 逻辑移位
相当于无符号数位移，左右移都补0
##### 循环移位
将溢出的位补充到空缺的位，比如 0x8 循环左移 1 位，结果是 0x1
如果是带进位位的循环移位，把进位位看成最高位即可
##### 原码的算数移位
符号位保持不变，仅对数值位进行移位
- 右移：高位补0，低位舍弃。若低位是0，相当于除以2；若低位是1，会丢失精度
- 左移：低位补0，高位舍弃。若高位是0，相当于乘以2；若高位是1，会严重误差
##### 反码的算数移位
符号位保持不变，仅对数值进行移位
- 若符号位是0，反码和原码相同，移位方式也与[[数据的表示和运算#原码的算数移位|原码的算数移位]]完全相同
- 若符号位是1，反码的数值位与原码相反，移位方式跟原码的移位方式唯一的不同点在于要补1
##### 补码的算数移位
符号位保持不变，仅对数值进行移位
- 若符号位是0，补码和原码相同，移位方式也与[[数据的表示和运算#原码的算数移位|原码的算数移位]]完全相同
- 若符号位为1，左移和右移处理方式不同：
	- 左移：低位补0
	- 右移：高位补1
##### 补码的加减运算
- 加法：补码在进行加法运算时，把包括符号位的整个补码看成是一个无符号整数，然后按照无符号数字的方式做加法（这样做之所以可行，主要是因为，假设要在8位字长的计算机中计算$A+B$，那么实际上的结果是$(A+B)$%256，其中A是负数，记A的补码为$A_{bin}$，把$A_{bin}$看成一个无符号数$A_{d}$，则有$A\equiv A_d(mod 256)$，根据同余理论，结果显然成立）
- 减法：做减法时，可以取反做加法，可以用[[数据的表示和运算#^c70e40|上述方法]]快速求相反数的补码
由上可知，其实==加减法都会用加法==器来运算
##### 有符号数溢出判断
以8位机为例
 1. 如果两个数字的和超过了127，那么称为发生了上溢：
	- 只有两个正数相加才会产生上溢
	- 上溢发生时，数值位往符号位进1，符号位不产生进位 ^2660e3
2. 如果两个数字的和小于-128，那么称为发生了下溢：
	- 只有两个负数相加才会产生下溢
	- 下溢发生时，数值位最高位不进位，符号位进1
由上述两种溢出的进位情况，可以设计[[数据的表示和运算#^148dd4|如上]]的溢出位的电路
##### 无符号数溢出判断
若是加法，最高位进位为1时发生了溢出
若是减法，最高位进位为0时发生了溢出