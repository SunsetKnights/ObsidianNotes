#### 指令的构成
- 一般的指令格式为：操作码+地址码
#### 按地址数分类
- 零地址指令：
	- 不需要操作数：停机指令、nop指令、空操作指令等
	- 堆栈计算机：操作数隐含对栈操作
- 一地址指令：
	- 一元运算指令——3次访存：读指令、读数、写数
	- 二元运算指令，但其中一个操作数隐含在某个寄存器中，结果写回寄存器——2次访存：读指令、读数
- 二地址指令：
	- 二元运算指令——访存4次：读指令、读操作数1、读操作数2、写结果
- 三地址指令：
	- 二元运算指令，但指定结果写回地址——访存4次：读指令、读操作数1、读操作数2、写结果
- 四地址指令：
	- 同三地址指令，但是加一个写入PC寄存器的地址
#### 扩展操作码
- 若n地址指令有$x_n$条，每条地址占y位，那么理论上，n-1地址指令的条数最多有$\displaystyle (2^{\left\lceil\log_2n\right\rceil}-n)\times2^y$条（考试的时候一般是这么算）
- 但其实在实际设计中，$\displaystyle (2^{\left\lceil\log_2n\right\rceil}-n)$的值一般为2的整数次方，这样做的好处是可以更方便的识别指令类型
- 例如，若指令字长8位、地址占4位，一地址指令有12条，那么可以把0000-1011分配给一地址指令，1100 0000-1111 0000分配给零地址指令，这样只需要判断最高位是否全为1，就可以知道指令类型了
#### 指令寻址
- PC寄存器中存放的一般是按字节编址的内存地址（下一条指令的地址）
- 顺序执行时，PC寄存器每次自增一个指令字长的字节数
- 执行转移指令时，直接改变PC寄存器的值
#### 数据寻址
- 数据寻址有很多种不同的方式，为了区分这些方式，在指令的操作码和地址码之间加入一些位，用来标识寻址方式，叫寻址特征字段，于是指令变成了：操作码+寻址特征+形式地址码  的方式
- <table align=center><thead><tr><th>寻址方式</th><th>有效地址</th><th>执行指令时的访存次数</th></tr></thead><tbody><tr><td>隐含寻址</td><td>程序指定</td><td>0</td></tr><tr><td>立即寻址</td><td>A即是操作数</td><td>0</td></tr><tr><td>直接寻址</td><td>EA=A</td><td>1</td></tr><tr><td>一次间接寻址</td><td>EA=(A)</td><td>2</td></tr><tr><td>寄存器寻址</td><td>EA=R</td><td>0</td></tr><tr><td>寄存器一次间接寻址</td><td>EA=(R)</td><td>1</td></tr><tr><td>相对寻址</td><td>EA=(PC)+A</td><td>1</td></tr><tr><td>基址寻址</td> <td>EA=(BR)+A</td><td>1</td></tr><tr><td>变址寻址</td> <td>EA=(IX)+A</td><td>1</td></tr><tr><td>堆栈寻址</td> <td>EA=(SP)/(SP+1)/(SP-1)</td><td>硬堆栈0次，软堆栈1次</td></tr></tbody></table>
- 表格中的简写含义如下：
	- EA（Effective Address）：有效地址
	- A（Address）：形式地址
	- R（Register）：寄存器
	- PC（Program Counter）：程序计数器
	- BR（Base address Register）：基址寄存器
	- IX（Index Register）：变址寄存器
	- SP（Stack Pointer）：栈指针
- 堆栈寻址中，出栈的有效地址一般是SP寄存器中的值，入栈的有效地址根据栈的增长方向不同，可能是SP+1或者SP-1